<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="Nodejs基础安装、运行什么的就不说了，网上一大堆教程。这部分主要是总结一下nodejs是什么，CMD模块系统要注意的。  nodejs是一个js脚本解析器，任何操作系统下安装NodeJS本质上做的事情都是把NodeJS执行程序复制到一个目录，然后保证这个目录在系统PATH环境变量下，以便终端下可以使用node命令 终端下直接输入node命令，可以进入命令行交互模式，很适合用来测试一些JS代码片">
<meta property="og:type" content="article">
<meta property="og:title" content="nodejs速学笔记（一）">
<meta property="og:url" content="http://yoursite.com/2017/07/21/nodejs速学笔记（一）/index.html">
<meta property="og:site_name" content="xixijiang的主页">
<meta property="og:description" content="Nodejs基础安装、运行什么的就不说了，网上一大堆教程。这部分主要是总结一下nodejs是什么，CMD模块系统要注意的。  nodejs是一个js脚本解析器，任何操作系统下安装NodeJS本质上做的事情都是把NodeJS执行程序复制到一个目录，然后保证这个目录在系统PATH环境变量下，以便终端下可以使用node命令 终端下直接输入node命令，可以进入命令行交互模式，很适合用来测试一些JS代码片">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-12-31T16:34:07.851Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="nodejs速学笔记（一）">
<meta name="twitter:description" content="Nodejs基础安装、运行什么的就不说了，网上一大堆教程。这部分主要是总结一下nodejs是什么，CMD模块系统要注意的。  nodejs是一个js脚本解析器，任何操作系统下安装NodeJS本质上做的事情都是把NodeJS执行程序复制到一个目录，然后保证这个目录在系统PATH环境变量下，以便终端下可以使用node命令 终端下直接输入node命令，可以进入命令行交互模式，很适合用来测试一些JS代码片">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/07/21/nodejs速学笔记（一）/">





  <title>nodejs速学笔记（一） | xixijiang的主页</title>
  














</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xixijiang的主页</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/21/nodejs速学笔记（一）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xixijiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xixijiang的主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">nodejs速学笔记（一）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-21T15:23:14+08:00">
                2017-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Nodejs基础"><a href="#Nodejs基础" class="headerlink" title="Nodejs基础"></a>Nodejs基础</h2><p>安装、运行什么的就不说了，网上一大堆教程。这部分主要是总结一下nodejs是什么，CMD模块系统要注意的。</p>
<ul>
<li>nodejs是一个js脚本解析器，任何操作系统下安装NodeJS本质上做的事情都是把NodeJS执行程序复制到一个目录，然后保证这个目录在系统PATH环境变量下，以便终端下可以使用node命令</li>
<li>终端下直接输入node命令，可以进入命令行交互模式，很适合用来测试一些JS代码片段，比如正则表达式。</li>
<li>NodeJS使用CMD模块系统，主模块作为程序入口点，所有模块在执行过程中只初始化一次。</li>
<li>除非JS模块不能满足需要，否则不要轻易使用二进制模块，否则用户会痛苦无比。</li>
</ul>
<h2 id="代码的组织和部署"><a href="#代码的组织和部署" class="headerlink" title="代码的组织和部署"></a>代码的组织和部署</h2><h3 id="模块路径解析规则"><a href="#模块路径解析规则" class="headerlink" title="模块路径解析规则"></a>模块路径解析规则</h3><p>路径解析一直没有研究过，总感觉是个心头病。。</p>
<p>require函数支持<code>/</code> 或磁盘符<code>C:</code>开头的绝对路径，也支持<code>./</code>开头的相对路径，绝对路径和相对路径当然不够灵活，我想动动文件位置就得更改一堆路径。</p>
<p>因此，require函数支持第三种形式的路径，写法类似于<code>foo/bar</code>，并一次按照以下规则解析路径，直到找到模块位置。</p>
<p>1、内置模块<br>如果传递给require函数的是Nodejs内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如：</p>
<pre><code>require(&apos;fs&apos;)    
</code></pre><p>2、node_modules目录<br>NodeJS定义了一个特殊的node_modules目录用于存放模块，例如某个模块的绝对路径是<code>/home/user/hello.js</code>, 在该模块中使用<code>require(&#39;foo/bar&#39;)</code>方式加载模块时，则NodeJS一次尝试使用以下路径。</p>
<pre><code>/home/user/node_modules/foo/bar
/home/node_modules/foo/bar
/node_modules/foo/bar
</code></pre><p>3、NODE_PATH环境变量<br>与PATH环境变量类似，NodeJS允许通过NODE_PATH环境变量来指定额外的模块搜索路径，NODE_PATH环境变量中包含一到多个目录路径，路径之间Linux下使用:分割，windows下使用;分割。例如，定义了以下NODE_PATH环境变量：</p>
<pre><code>NODE_PATH=/home/user/lib:/home/lib
</code></pre><p>当使用require(‘foo/bar’)的方式加载模块时，则NodeJS依次尝试以下路径。</p>
<pre><code>/home/user/lib/foo/bar
 /home/lib/foo/bar
</code></pre><h3 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h3><p>JS模块的基本单位是js文件，但复杂些的模块往往由多个子模块组成。这些子模块往往有一个入口模块，在使用时只需要加载入口模块即可。如下目录结构，cat是一个包，里面包含head.js.body.js,main.js，其中main.js是入口模块，加载方式就是<code>require(&#39;home/user/lib/cat/main.js&#39;)</code>，但是如果我们把main.js改成index.js，引入入口模块的时候就只需要写成require(‘home/user/lib/cat’)的形式，程序会自动寻找index.js的。</p>
<pre><code>- /home/user/lib/
- cat/
    head.js
    body.js
    main.js
</code></pre><p>进而，如果想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个package.json文件，并在其中指定入口模块的路径。上例中的cat模块可以重构如下：</p>
<pre><code>- /home/user/lib/
- cat/
    + doc/
    - lib/
        head.js
        body.js
        main.js
    + tests/
    package.json
</code></pre><p>其中package.json内容如下：</p>
<pre><code>{
    &quot;name&quot;: &quot;cat&quot;,
    &quot;main&quot;: &quot;./lib/main.js&quot;
}
</code></pre><p>如此一来，就同样可以使用<code>require(&#39;/home/user/lib/cat&#39;)</code>的方式加载模块。NodeJS会根据包目录下的package.json找到入口模块所在位置。</p>
<h3 id="命令行程序"><a href="#命令行程序" class="headerlink" title="命令行程序"></a>命令行程序</h3><p>使用NodeJS编写的东西，要么是一个包，要么是一个命令行程序，而前者最终也会用于开发后者。因此我们在部署代码时需要一些技巧，让用户觉得自己是在使用一个命令行程序。</p>
<p>例如我们用NodeJS写了个程序，可以把命令行参数原样打印出来。该程序很简单，在主模块内实现了所有功能。并且写好后，我们把该程序部署在/home/user/bin/node-echo.js这个位置。为了在任何目录下都能运行该程序，我们需要使用以下终端命令。</p>
<pre><code>$ node /home/user/bin/node-echo.js Hello World
Hello World
</code></pre><p>这种使用方式看起来不怎么像是一个命令行程序，下边的才是我们期望的方式。</p>
<pre><code>$ node-echo Hello World
</code></pre><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>在Linux系统下，我们可以把JS文件当作shell脚本来运行，从而达到上述目的，具体步骤如下：</p>
<p>1、在shell脚本中，可以通过<code>#!</code>注释来指定当前脚本使用的解析器。所以我们首先在<code>node-echo.js</code>文件顶部增加以下一行注释，表明当前脚本使用NodeJS解析。</p>
<pre><code>#! /usr/bin/env node
</code></pre><p>NodeJS会忽略掉位于JS模块首行的#!注释，不必担心这行注释是非法语句。</p>
<p>2、然后，我们使用以下命令赋予<code>node-echo.js</code>文件执行权限。</p>
<pre><code>$ chmod +x /home/user/bin/node-echo.js
</code></pre><p>这样处理后，我们就可以在任何目录下使用node-echo命令了。</p>
<h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>在Windows系统下的做法完全不同，我们得靠.cmd文件来解决问题。假设<code>node-echo.js</code>存放在<code>C:\Users\user\bin</code>目录，并且该目录已经添加到PATH环境变量里了。接下来需要在该目录下新建一个名为<code>node-echo.cmd</code>的文件，文件内容如下：</p>
<pre><code>@node &quot;C:\User\user\bin\node-echo.js&quot; %*
</code></pre><p>这样处理后，我们就可以在任何目录下使用node-echo命令了。</p>
<h3 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h3><p>了解了以上知识后，现在我们可以来完整地规划一个工程目录了。以编写一个命令行程序为例，一般我们会同时提供命令行模式和API模式两种使用方式，并且我们会借助三方包来编写代码。除了代码外，一个完整的程序也应该有自己的文档和测试用例。因此，一个标准的工程目录都看起来像下边这样。</p>
<pre><code>- /home/user/workspace/node-echo/   # 工程目录
    - bin/                          # 存放命令行相关代码
        node-echo
    + doc/                          # 存放文档
    - lib/                          # 存放API相关代码
        echo.js
    - node_modules/                 # 存放三方包
        + argv/
    + tests/                        # 存放测试用例
    package.json                    # 元数据文件
    README.md                       # 说明文件
</code></pre><h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><p>会用就行了，不求甚解哈哈~~</p>
<h4 id="下载第三方包"><a href="#下载第三方包" class="headerlink" title="下载第三方包"></a>下载第三方包</h4><p>比如上边例子中的argv，就可以在工程目录下打开终端，使用以下命令来下载三方包。</p>
<pre><code>$ npm install argv
...
argv@0.0.2 node_modules\argv
</code></pre><p>下载好之后，argv包就放在了工程目录下的node_modules目录中，因此在代码中只需要通过<code>require(&#39;argv&#39;)</code>的方式就好，无需指定三方包路径。</p>
<p>以上命令默认下载最新版三方包，如果想要下载指定版本的话，可以在包名后边加上<code>@&lt;version&gt;</code>，例如通过以下命令可下载0.0.1版的argv。</p>
<pre><code>$ npm install argv@0.0.1
...
argv@0.0.1 node_modules\argv
</code></pre><p>如果使用到的三方包比较多，在终端下一个包一条命令地安装未免太人肉了。因此NPM对<code>package.json</code>的字段做了扩展，允许在其中申明三方包依赖。因此，上边例子中的<code>package.json</code>可以改写如下：</p>
<pre><code>{
    &quot;name&quot;: &quot;node-echo&quot;,
    &quot;main&quot;: &quot;./lib/echo.js&quot;,
    &quot;dependencies&quot;: {
        &quot;argv&quot;: &quot;0.0.2&quot;
    }
}
</code></pre><p>这样处理后，在工程目录下就可以使用<code>npm install</code>命令批量安装三方包了。更重要的是，当以后<code>node-echo</code>也上传到了NPM服务器，别人下载这个包时，NPM会根据包中申明的三方包依赖自动下载进一步依赖的三方包。例如，使用<code>npm install node-echo</code>命令时，NPM会自动创建以下目录结构。</p>
<pre><code>- project/
    - node_modules/
        - node-echo/
               - node_modules/
                + argv/
            ...
    ...
</code></pre><p>如此一来，用户只需关心自己直接使用的三方包，不需要自己去解决所有包的依赖关系。</p>
<h4 id="安装命令行程序"><a href="#安装命令行程序" class="headerlink" title="安装命令行程序"></a>安装命令行程序</h4><p>从NPM服务上下载安装一个命令行程序的方法与三方包类似。例如上例中的node-echo提供了命令行使用方式，只要node-echo自己配置好了相关的package.json字段，对于用户而言，只需要使用以下命令安装程序。</p>
<pre><code>$ npm install node-echo -g
</code></pre><p>参数中的-g表示全局安装，因此node-echo会默认安装到以下位置，并且NPM会自动创建好Linux系统下需要的软链文件或Windows系统下需要的.cmd文件。</p>
<pre><code>- /usr/local/               # Linux系统下
        - lib/node_modules/
            + node-echo/
            ...
        - bin/
            node-echo
            ...
        ...

    - %APPDATA%\npm\            # Windows系统下
        - node_modules\
            + node-echo\
            ...
        node-echo.cmd
        ...
</code></pre><h4 id="发布代码"><a href="#发布代码" class="headerlink" title="发布代码"></a>发布代码</h4><p>第一次使用NPM发布代码前需要注册一个账号。终端下运行<code>npm adduser</code>，之后按照提示做即可。账号搞定后，接着我们需要编辑package.json文件，加入NPM必需的字段。接着上边node-echo的例子，package.json里必要的字段如下。</p>
<pre><code>{
        &quot;name&quot;: &quot;node-echo&quot;,           # 包名，在NPM服务器上须要保持唯一
        &quot;version&quot;: &quot;1.0.0&quot;,            # 当前版本号
        &quot;dependencies&quot;: {              # 三方包依赖，需要指定包名和版本号
            &quot;argv&quot;: &quot;0.0.2&quot;
          },
        &quot;main&quot;: &quot;./lib/echo.js&quot;,       # 入口模块位置
        &quot;bin&quot; : {
            &quot;node-echo&quot;: &quot;./bin/node-echo&quot;      # 命令行程序名和主模块位置
        }
    }
</code></pre><p>之后，我们就可以在package.json所在目录下运行npm publish发布代码了。</p>
<h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。</p>
<p>语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p>
<ul>
<li><p>如果只是修复bug，需要更新Z位。</p>
</li>
<li><p>如果是新增了功能，但是向下兼容，需要更新Y位。</p>
</li>
<li><p>如果有大变动，向下不兼容，需要更新X位。<br>版本号有了这个保证后，在申明三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如”argv”: “0.0.x”表示依赖于0.0.x系列的最新版argv。NPM支持的所有版本号范围指定方式可以查看官方文档。</p>
</li>
</ul>
<h4 id="灵机一点"><a href="#灵机一点" class="headerlink" title="灵机一点"></a>灵机一点</h4><p>除了本章介绍的部分外，NPM还提供了很多功能，package.json里也有很多其它有用的字段。除了可以在npmjs.org/doc/查看官方文档外，这里再介绍一些NPM常用命令。</p>
<p>NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。</p>
<p>使用npm help <command>可查看某条命令的详细帮助，例如<code>npm help install</code>。</p>
<p>在package.json所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</p>
<p>使用<code>npm update &lt;package&gt;</code>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。</p>
<p>使用<code>npm update &lt;package&gt; -g</code>可以把全局安装的对应命令行程序更新至最新版。</p>
<p>使用<code>npm cache clear</code>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</p>
<p>使用<code>npm unpublish &lt;package&gt;@&lt;version&gt;</code>可以撤销发布自己发布过的某个版本代码。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本章介绍了使用NodeJS编写代码前需要做的准备工作，总结起来有以下几点：</p>
<ul>
<li><p>编写代码前先规划好目录结构，才能做到有条不紊。</p>
</li>
<li><p>稍大些的程序可以将代码拆分为多个模块管理，更大些的程序可以使用包来组织模块。</p>
</li>
<li><p>合理使用node_modules和NODE_PATH来解耦包的使用方式和物理路径。</p>
</li>
<li><p>使用NPM加入NodeJS生态圈互通有无。</p>
</li>
<li><p>想到了心仪的包名时请提前在NPM上抢注。</p>
</li>
</ul>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><p>NodeJS提供了基本的文件操作API，但是像文件拷贝这种高级功能就没有提供，因此我们先拿文件拷贝程序练手。与copy命令类似，我们的程序需要能接受源文件路径与目标文件路径两个参数。</p>
<h4 id="小文件拷贝"><a href="#小文件拷贝" class="headerlink" title="小文件拷贝"></a>小文件拷贝</h4><p>我们使用NodeJS内置的fs模块简单实现这个程序如下。</p>
<pre><code>var fs = require(&apos;fs&apos;);

function copy(src, dst) {
    fs.writeFileSync(dst, fs.readFileSync(src));
}

function main(argv) {
    copy(argv[0], argv[1]);
}

main(process.argv.slice(2));
</code></pre><p>以上程序使用fs.readFileSync从源路径读取文件内容，并使用fs.writeFileSync将文件内容写入目标路径。</p>
<pre><code>process是一个全局变量，可通过process.argv获得命令行参数。由于argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径，因此第一个命令行参数从argv[2]这个位置开始。
</code></pre><h4 id="大文件拷贝"><a href="#大文件拷贝" class="headerlink" title="大文件拷贝"></a>大文件拷贝</h4><p>上边的程序拷贝一些小文件没啥问题，但这种一次性把所有文件内容都读取到内存中后再一次性写入磁盘的方式不适合拷贝大文件，内存会爆仓。对于大文件，我们只能读一点写一点，直到完成拷贝。因此上边的程序需要改造如下。</p>
<pre><code>var fs = require(&apos;fs&apos;);

function copy(src, dst) {
    fs.createReadStream(src).pipe(fs.createWriteStream(dst));
}

function main(argv) {
    copy(argv[0], argv[1]);
}

main(process.argv.slice(2));
</code></pre><p>以上程序使用<code>fs.createReadStream</code>创建了一个源文件的只读数据流，并使用<code>fs.createWriteStream</code>创建了一个目标文件的只写数据流，并且用pipe方法把两个数据流连接了起来。连接起来后发生的事情，说得抽象点的话，水顺着水管从一个桶流到了另一个桶。</p>
<h3 id="API走马观花"><a href="#API走马观花" class="headerlink" title="API走马观花"></a>API走马观花</h3><p>我们先大致看看NodeJS提供了哪些和文件操作有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。</p>
<h4 id="Buffer（数据块）"><a href="#Buffer（数据块）" class="headerlink" title="Buffer（数据块）"></a>Buffer（数据块）</h4><p>S语言自身只有字符串数据类型，没有二进制数据类型，因此NodeJS提供了一个与String对等的全局构造函数Buffer来提供对二进制数据的操作。</p>
<ul>
<li><p>除了可以读取文件得到Buffer的实例外，还能够直接构造，例如：</p>
<p>  var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</p>
</li>
<li><p>有length属性</p>
</li>
<li>可以用下标访问: bin[0]</li>
<li><p>与字符串能够互相转化</p>
<ul>
<li>使用指定编码将二进制数据转化为字符串<br>  <code>var str = bin.toString(&#39;utf-8&#39;); // =&gt; &quot;hello&quot;</code></li>
<li>将字符串转换为指定编码下的二进制数据：<br>  <code>var bin = new Buffer(&#39;hello&#39;, &#39;utf-8&#39;); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;</code></li>
</ul>
</li>
<li><p>Buffer不是只读的（字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。），更像是可以做指针操作的C语言数组。例如，可以用[index]方式直接修改某个位置的字节。</p>
<ul>
<li>bin[0] = 0x48;</li>
</ul>
</li>
<li><p>而.slice方法也不是返回一个新的Buffer，而更像是返回了指向原Buffer中间的某个位置的指针</p>
<p>  `[ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]</p>
<pre><code> ^           ^
 |           |
bin     bin.slice(2)`
</code></pre><p>  因此对.slice方法返回的Buffer的修改会作用于原Buffer，例如：</p>
<pre><code>var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);
var sub = bin.slice(2);

sub[0] = 0x65;
console.log(bin); // =&gt; &lt;Buffer 68 65 65 6c 6f&gt; ```
</code></pre><p>也因此，如果想要拷贝一份Buffer，得首先创建一个新的Buffer，并通过.copy方法把原Buffer中的数据复制过去。这个类似于申请一块新的内存，并把已有内存中的数据复制过去。以下是一个例子。</p>
<pre><code>var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);
var dup = new Buffer(bin.length);

bin.copy(dup);
dup[0] = 0x48;
console.log(bin); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;
console.log(dup); // =&gt; &lt;Buffer 48 65 65 6c 6f&gt;
</code></pre></li>
</ul>
<p>总之，Buffer将JS的数据处理能力从字符串扩展到了任意二进制数据。</p>
<h4 id="Stream-数据流"><a href="#Stream-数据流" class="headerlink" title="Stream(数据流)"></a>Stream(数据流)</h4><p>当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。NodeJS中通过各种Stream来提供对数据流的操作。</p>
<p>以上边的大文件拷贝程序为例，我们可以为数据来源创建一个只读数据流，示例如下：</p>
<pre><code>var rs = fs.createReadStream(pathname);

    rs.on(&apos;data&apos;, function (chunk) {
        doSomething(chunk);
    });

    rs.on(&apos;end&apos;, function () {
        cleanUp();
    });
</code></pre><p><code>Stream基于事件机制工作，所有Stream的实例都继承于NodeJS提供的EventEmitter。</code></p>
<p>上边的代码中data事件会源源不断地被触发，不管doSomething函数是否处理得过来。代码可以继续做如下改造，以解决这个问题。</p>
<pre><code>var rs = fs.createReadStream(src);

    rs.on(&apos;data&apos;, function (chunk) {
        rs.pause();
        doSomething(chunk, function () {
            rs.resume();
        });
    });

    rs.on(&apos;end&apos;, function () {
        cleanUp();
    });
</code></pre><p>以上代码给doSomething函数加上了回调，因此我们可以在处理数据前暂停数据读取，并在处理数据后继续读取数据。</p>
<p>此外，我们也可以为数据目标创建一个只写数据流，示例如下：</p>
<pre><code>var rs = fs.createReadStream(src);
    var ws = fs.createWriteStream(dst);

    rs.on(&apos;data&apos;, function (chunk) {
        ws.write(chunk);
    });

    rs.on(&apos;end&apos;, function () {
        ws.end();
    });
</code></pre><p>我们把doSomething换成了往只写数据流里写入数据后，以上代码看起来就像是一个文件拷贝程序了。但是以上代码存在上边提到的问题，如果写入速度跟不上读取速度的话，只写数据流内部的缓存会爆仓。我们可以根据<code>.write</code>方法的返回值来判断传入的数据是写入目标了，还是临时放在了缓存了，并根据<code>drain</code>事件来判断什么时候只写数据流已经将缓存中的数据写入目标，可以传入下一个待写数据了。因此代码可以改造如下：</p>
<pre><code>var rs = fs.createReadStream(src);
    var ws = fs.createWriteStream(dst);

    rs.on(&apos;data&apos;, function (chunk) {
        if (ws.write(chunk) === false) {
            rs.pause();
        }
    });

    rs.on(&apos;end&apos;, function () {
        ws.end();
    });

    ws.on(&apos;drain&apos;, function () {
        rs.resume();
    });
</code></pre><p>以上代码实现了数据从只读数据流到只写数据流的搬运，并包括了防爆仓控制。因为这种使用场景很多，例如上边的大文件拷贝程序，NodeJS直接提供了.pipe方法来做这件事情，其内部实现方式与上边的代码类似。</p>
<h4 id="File-System（文件系统）"><a href="#File-System（文件系统）" class="headerlink" title="File System（文件系统）"></a>File System（文件系统）</h4><p>NodeJS通过fs内置模块提供对文件的操作。fs模块提供的API基本上可以分为以下三类：</p>
<ul>
<li>文件属性读写。</li>
</ul>
<p>其中常用的有fs.stat、fs.chmod、fs.chown等等。</p>
<ul>
<li>文件内容读写。</li>
</ul>
<p>其中常用的有fs.readFile、fs.readdir、fs.writeFile、fs.mkdir等等。</p>
<ul>
<li>底层文件操作。</li>
</ul>
<p>其中常用的有fs.open、fs.read、fs.write、fs.close等等。</p>
<p><strong>NodeJS最精华的异步IO模型</strong>在fs模块里有着充分的体现，例如上边提到的这些API都通过<strong>回调函数</strong>传递结果。以fs.readFile为例：</p>
<pre><code>fs.readFile(pathname, function (err, data) {
    if (err) {
        // Deal with error.
    } else {
        // Deal with data.
    }
});
</code></pre><p>如上边代码所示，基本上所有fs模块API的回调参数都有两个。第一个参数在有错误发生时等于异常对象，第二个参数始终用于返回API方法执行结果。</p>
<p>此外，fs模块的所有异步API都有对应的同步版本，用于无法使用异步操作时，或者同步操作更方便时的情况。同步API除了方法名的末尾多了一个Sync之外，异常对象与执行结果的传递方式也有相应变化。同样以fs.readFileSync为例：</p>
<pre><code>try {
    var data = fs.readFileSync(pathname);
    // Deal with data.
} catch (err) {
    // Deal with error.
}
</code></pre><h4 id="Path-路径"><a href="#Path-路径" class="headerlink" title="Path(路径)"></a>Path(路径)</h4><p>操作文件时难免不与文件路径打交道。NodeJS提供了path内置模块来简化路径相关操作，并提升代码可读性。以下分别介绍几个常用的API。</p>
<ul>
<li><p>path.normalize</p>
<p>  将传入的路径转换为标准路径，具体讲的话，除了解析路径中的.与..外，还能去掉多余的斜杠。如果有程序需要使用路径作为某些数据的索引，但又允许用户随意输入路径时，就需要使用该方法保证路径的唯一性。以下是一个例子：</p>
<pre><code>var cache = {};

function store(key, value) {
    cache[path.normalize(key)] = value;
}

store(&apos;foo/bar&apos;, 1);
store(&apos;foo//baz//../bar&apos;, 2);
console.log(cache);  // =&gt; { &quot;foo/bar&quot;: 2 }
</code></pre></li>
</ul>
<p><code>**坑出没注意**： 标准化之后的路径里的斜杠在Windows系统下是\，而在Linux系统下是/。如果想保证任何系统下都使用/作为路径分隔符的话，需要用.replace(/\\/g, &#39;/&#39;)再替换一下标准路径。</code></p>
<ul>
<li><p>path.join</p>
<p>  将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。以下是一个例子：</p>
<pre><code>path.join(&apos;foo/&apos;, &apos;baz/&apos;, &apos;../bar&apos;); // =&gt; &quot;foo/bar&quot;
</code></pre></li>
<li><p>path.extname</p>
<p>  当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。以下是一个例子：</p>
<pre><code>path.extname(&apos;foo/bar.js&apos;); // =&gt; &quot;.js&quot;
</code></pre></li>
</ul>
<h4 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h4><p>遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录。</p>
<ul>
<li><p>递归算法<br>  遍历目录时一般使用递归算法，否则就难以编写出简洁的代码。递归算法与数学归纳法类似，通过不断缩小问题的规模来解决问题。以下示例说明了这种方法。</p>
<pre><code>function factorial(n) {
    if (n === 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
</code></pre></li>
</ul>
<p><code>**陷阱**：使用递归算法编写的代码虽然简洁，但由于每递归一次就产生一次函数调用，在需要优先考虑性能时，需要把递归算法转换为循环算法，以减少函数调用次数。</code></p>
<ul>
<li><p>遍历算法</p>
<p>  目录是一个树状结构，在遍历时一般使用深度优先+先序遍历算法。深度优先，意味着到达一个节点后，首先接着遍历子节点而不是邻居节点。先序遍历，意味着首次到达了某节点就算遍历完成，而不是最后一次返回某节点才算数。因此使用这种遍历方式时，下边这棵树的遍历顺序是A &gt; B &gt; D &gt; E &gt; C &gt; F。</p>
<pre><code>   A
 / \
B   C
  / \   \
D   E   F
</code></pre></li>
<li><p>同步遍历<br>  了解了必要的算法后，我们可以简单地实现以下目录遍历函数。</p>
<pre><code>function travel(dir, callback) {
    fs.readdirSync(dir).forEach(function (file) {
        var pathname = path.join(dir, file);

        if (fs.statSync(pathname).isDirectory()) {
            travel(pathname, callback);
        } else {
            callback(pathname);
        }
    });
}
</code></pre></li>
</ul>
<p>可以看到，该函数以某个目录作为遍历的起点。遇到一个子目录时，就先接着遍历子目录。遇到一个文件时，就把文件的绝对路径传给回调函数。回调函数拿到文件路径后，就可以做各种判断和处理。因此假设有以下目录：</p>
<pre><code>- /home/user/
    - foo/
        x.js
    - bar/
        y.js
    z.css
</code></pre><p>使用以下代码遍历该目录时，得到的输入如下。</p>
<pre><code>travel(&apos;/home/user&apos;, function (pathname) {
        console.log(pathname);
    });

    ------------------------
    /home/user/foo/x.js
    /home/user/bar/y.js
    /home/user/z.css
</code></pre><ul>
<li><p>异步遍历</p>
<p>  如果读取目录或读取文件状态时使用的是异步API，目录遍历函数实现起来会有些复杂，但原理完全相同。travel函数的异步版本如下。</p>
<pre><code>function travel(dir, callback, finish) {
    fs.readdir(dir, function (err, files) {
        (function next(i) {
            if (i &lt; files.length) {
                var pathname = path.join(dir, files[i]);

                fs.stat(pathname, function (err, stats) {
                    if (stats.isDirectory()) {
                        travel(pathname, callback, function () {
                            next(i + 1);
                        });
                    } else {
                        callback(pathname, function () {
                            next(i + 1);
                        });
                    }
                });
            } else {
                finish &amp;&amp; finish();
            }
        }(0));
    });
}
</code></pre></li>
</ul>
<p>这里不详细介绍异步遍历函数的编写技巧，在后续章节中会详细介绍这个。总之我们可以看到异步编程还是蛮复杂的。</p>
<h4 id="文本编码"><a href="#文本编码" class="headerlink" title="文本编码"></a>文本编码</h4><pre><code>使用NodeJS编写前端工具时，操作得最多的是文本文件，因此也就涉及到了文件编码的处理问题。我们常用的文本编码有UTF8和GBK两种，并且UTF8文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的UTF8编码字符串后才能正常处理。
</code></pre><ul>
<li><p>BOM的移除</p>
<p>  BOM用于标记一个文本文件使用Unicode编码，其本身是一个Unicode字符（”\uFEFF”），位于文本文件头部。在不同的Unicode编码下，BOM字符对应的二进制字节如下：</p>
<pre><code>Bytes      Encoding
----------------------------
FE FF       UTF16BE
FF FE       UTF16LE
EF BB BF    UTF8
</code></pre></li>
</ul>
<p>因此，我们可以根据文本文件头几个字节等于啥来判断文件是否包含BOM，以及使用哪种Unicode编码。但是，BOM字符虽然起到了标记文件编码的作用，其本身却不属于文件内容的一部分，如果读取文本文件时不去掉BOM，在某些使用场景下就会有问题。例如我们把几个JS文件合并成一个文件后，如果文件中间含有BOM字符，就会导致浏览器JS语法错误。因此，使用NodeJS读取文本文件时，一般需要去掉BOM。例如，以下代码实现了识别和去除UTF8 BOM的功能。</p>
<pre><code>function readText(pathname) {
        var bin = fs.readFileSync(pathname);

        if (bin[0] === 0xEF &amp;&amp; bin[1] === 0xBB &amp;&amp; bin[2] === 0xBF) {
            bin = bin.slice(3);
        }

        return bin.toString(&apos;utf-8&apos;);
    }
</code></pre><ul>
<li><p>GBK转UTF8</p>
<p>  NodeJS支持在读取文本文件时，或者在Buffer转换为字符串时指定文本编码，但遗憾的是，GBK编码不在NodeJS自身支持范围内。因此，一般我们借助<code>iconv-lite</code>这个三方包来转换编码。使用NPM下载该包后，我们可以按下边方式编写一个读取GBK文本文件的函数。</p>
<pre><code>var iconv = require(&apos;iconv-lite&apos;);

function readGBKText(pathname) {
    var bin = fs.readFileSync(pathname);

    return iconv.decode(bin, &apos;gbk&apos;);
}
</code></pre></li>
<li><p>单字节编码</p>
<p>  有时候，我们无法预知需要读取的文件采用哪种编码，因此也就无法指定正确的编码。比如我们要处理的某些CSS文件中，有的用GBK编码，有的用UTF8编码。虽然可以一定程度可以根据文件的字节内容猜测出文本编码，但这里要介绍的是有些局限，但是要简单得多的一种技术。</p>
<p>  首先我们知道，如果一个文本文件只包含英文字符，比如Hello World，那无论用GBK编码或是UTF8编码读取这个文件都是没问题的。这是因为在这些编码下，ASCII0~128范围内字符都使用相同的单字节编码。</p>
<p>  反过来讲，即使一个文本文件中有中文等字符，如果我们需要处理的字符仅在ASCII0~128范围内，比如除了注释和字符串以外的JS代码，我们就可以统一使用单字节编码来读取文件，不用关心文件的实际编码是GBK还是UTF8。以下示例说明了这种方法。</p>
<pre><code>1. GBK编码源文件内容：
    var foo = &apos;中文&apos;;
2. 对应字节：
    76 61 72 20 66 6F 6F 20 3D 20 27 D6 D0 CE C4 27 3B
3. 使用单字节编码读取后得到的内容：
    var foo = &apos;{乱码}{乱码}{乱码}{乱码}&apos;;
4. 替换内容：
    var bar = &apos;{乱码}{乱码}{乱码}{乱码}&apos;;
5. 使用单字节编码保存后对应字节：
    76 61 72 20 62 61 72 20 3D 20 27 D6 D0 CE C4 27 3B
6. 使用GBK编码读取后得到内容：
    var bar = &apos;中文&apos;;
</code></pre></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/21/模板引擎/" rel="next" title="模板引擎">
                <i class="fa fa-chevron-left"></i> 模板引擎
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/22/react笔记/" rel="prev" title="react笔记">
                react笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="xixijiang">
          <p class="site-author-name" itemprop="name">xixijiang</p>
           
              <p class="site-description motion-element" itemprop="description">切莫停下前进的脚步</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">74</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Nodejs基础"><span class="nav-number">1.</span> <span class="nav-text">Nodejs基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码的组织和部署"><span class="nav-number">2.</span> <span class="nav-text">代码的组织和部署</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模块路径解析规则"><span class="nav-number">2.1.</span> <span class="nav-text">模块路径解析规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包（package）"><span class="nav-number">2.2.</span> <span class="nav-text">包（package）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命令行程序"><span class="nav-number">2.3.</span> <span class="nav-text">命令行程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux"><span class="nav-number">2.3.1.</span> <span class="nav-text">Linux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#windows"><span class="nav-number">2.3.2.</span> <span class="nav-text">windows</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工程目录"><span class="nav-number">2.4.</span> <span class="nav-text">工程目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NPM"><span class="nav-number">2.5.</span> <span class="nav-text">NPM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#下载第三方包"><span class="nav-number">2.5.1.</span> <span class="nav-text">下载第三方包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#安装命令行程序"><span class="nav-number">2.5.2.</span> <span class="nav-text">安装命令行程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发布代码"><span class="nav-number">2.5.3.</span> <span class="nav-text">发布代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#版本号"><span class="nav-number">2.5.4.</span> <span class="nav-text">版本号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#灵机一点"><span class="nav-number">2.5.5.</span> <span class="nav-text">灵机一点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">2.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件操作"><span class="nav-number">3.</span> <span class="nav-text">文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件拷贝"><span class="nav-number">3.1.</span> <span class="nav-text">文件拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小文件拷贝"><span class="nav-number">3.1.1.</span> <span class="nav-text">小文件拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#大文件拷贝"><span class="nav-number">3.1.2.</span> <span class="nav-text">大文件拷贝</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#API走马观花"><span class="nav-number">3.2.</span> <span class="nav-text">API走马观花</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Buffer（数据块）"><span class="nav-number">3.2.1.</span> <span class="nav-text">Buffer（数据块）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stream-数据流"><span class="nav-number">3.2.2.</span> <span class="nav-text">Stream(数据流)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#File-System（文件系统）"><span class="nav-number">3.2.3.</span> <span class="nav-text">File System（文件系统）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Path-路径"><span class="nav-number">3.2.4.</span> <span class="nav-text">Path(路径)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历目录"><span class="nav-number">3.2.5.</span> <span class="nav-text">遍历目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文本编码"><span class="nav-number">3.2.6.</span> <span class="nav-text">文本编码</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xixijiang</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
